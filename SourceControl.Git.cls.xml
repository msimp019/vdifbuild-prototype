<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25" zv="Cache for Windows (x86-64) 2018.1.1 (Build 312_1_18859U)" ts="2019-12-18 11:09:13">
<Class name="User.SourceControl.Git.Dialogue">
<Description><![CDATA[
<a href="http://www.readycomputing.com/">
<img src="http://www.readycomputing.com/images/header/headerLogo.png" alt="Ready Computing" >
</a>
<br>
Source control dialogue page]]></Description>
<IncludeCode>HS.Common</IncludeCode>
<Super>HS.UI.Template</Super>
<TimeChanged>65289,52358.188766</TimeChanged>
<TimeCreated>63685,58313.468979</TimeCreated>
<DependsOn>HS.UI.Custom.tablePane,HS.UI.Custom.tabGroup</DependsOn>

<Parameter name="RESOURCE">
<Description>
Security requirement</Description>
<Default>AH_SourceControl</Default>
</Parameter>

<Property name="PageTitle">
<Description>
Page title</Description>
<Type>%ZEN.Datatype.caption</Type>
<InitialExpression>$$$TextHTML("Source Control")</InitialExpression>
</Property>

<Parameter name="NoDialogueActions">
<Default>,Status,Pull,Push,Add,Pull from Develop,Pull from Team,Diff with Team,</Default>
</Parameter>

<XData name="detailPane">
<Description>
This XML block defines the contents of this page.</Description>
<XMLNamespace>http://www.intersystems.com/zen</XMLNamespace>
<Data><![CDATA[
<pane xmlns="http://www.intersystems.com/zen">
<form id="DialogueForm" method="post" labelPosition="left" OnSubmitForm="SubmitForm" hidden="true">
<text id="UserAction" hidden="true" name="UserAction" label="hidden field for storing user action" required="false" size="100"/>
<text id="NoDialogueActions" hidden="true" name="NoDialogueActions" label="hidden field for storing user action" required="false" size="100"/>
<text id="Commit" hidden="true" name="Commit" label="Commit Comment:" required="false" size="100"/>
<select id="Switch to Branch" hidden="true" name="Switch to Branch" showEmpty="false" width="100" label="Switch to Branch:" required="false"/>
<text id="Create Feature Branch" hidden="true" name="Create Feature Branch" label="Branch name: feature/" required="false" size="100"/>
<text id="Create Release Branch" hidden="true" name="Create Release Branch" label="Release name: release/" required="false" size="100"/>
<select id="Merge From Branch" hidden="true" name="Merge From Branch" showEmpty="false" width="100" label="Merge From Branch:" required="false"/>
<password id="Clone Repository" hidden="true" name="Clone Repository" label="Repository user account password:" required="false" size="100"/>
<html id="Merge to Team and Delete" hidden="true"/>
<submit caption="Submit"/>
</form>
<html id="Output" hidden="true" OnDrawContent="DrawOutput"/>
</pane>
]]></Data>
</XData>

<Method name="DrawOutput">
<FormalSpec>seed:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tSC As %Status = $$$OK
	#dim e As %Exception.AbstractException
	
	Try {
		
		if $D(%session.Data("Output"))>0 {
			Set ..%GetComponentById("Output").hidden=0
			
			for i=1:1:%session.Data("Output") {
				s tOutputLine = %session.Data("Output",i)
				&html<
					#(tOutputLine)#
					<br>
				>
			}
			Kill %session.Data("Output")
			Kill %session.Data("UserAction")
		}
		
	} catch e {
		s tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="SubmitForm">
<Description>
Callback to process values submitted for form.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pSubmit:%ZEN.Submit</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tSettings As %String
	
	Set tUserAction = pSubmit.%GetValue("UserAction")
	
	if $D(pSubmit.%Data(tUserAction))>0 {
		Set tSettings(tUserAction)=pSubmit.%GetValue(tUserAction)
	} else {
		Set tSettings(tUserAction)=""
	}
	
	s tSC = ##class(User.SourceControl.Git.Utils).HandleDialogue(.tSettings,.tOutput)
	Q:$$$ISERR(tSC) tSC
	
	merge %session.Data("Output") = tOutput
	Set %session.Data("UserAction") = tUserAction
	
	QUIT $$$OK
]]></Implementation>
</Method>

<Method name="%OnAfterCreatePage">
<Description><![CDATA[
This callback is called after the server-side page 
object and all of its children are created.<br/>
Subclasses can override this to add, remove, or modify 
items within the page object model, or to provide values
for controls.]]></Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tUserAction = $G(%request.Data("UserAction",1))
	Set ..%GetComponentById("UserAction").value = tUserAction
	Set ..%GetComponentById("NoDialogueActions").value = ..#NoDialogueActions
	
	if tUserAction'="" {
		
		if $F(..#NoDialogueActions, ","_tUserAction_",") > 0 {
			
		} else {
			Set ..%GetComponentById("DialogueForm").hidden=0
			Set ..%GetComponentById(tUserAction).hidden=0
			
			if tUserAction="Switch to Branch" {
				Set ..%GetComponentById(tUserAction).valueList = ##class(User.SourceControl.Git.Utils).BranchList()
			} elseif tUserAction="Merge to Team and Delete" {
				Set ..%GetComponentById(tUserAction).content = "Please confirm:<br><br>Merge from: "_##class(User.SourceControl.Git.Utils).CurrentBranch()_"<br>Merge to: "_##class(User.SourceControl.Git.Utils).TeamBranch()_"<br><br>Once merge is completed, "_##class(User.SourceControl.Git.Utils).CurrentBranch()_" will be deleted.<br><br>"
			}

			
		}
		
	} else {
		Set ..%GetComponentById("Output").hidden=0
	}
		
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="onloadHandler">
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var noDialogueActions = zenPage.getComponentById("NoDialogueActions").value
	var userAction = zenPage.getComponentById("UserAction").value
	var n = noDialogueActions.indexOf(userAction)
	if (n > 0) {
		zenPage.getComponentById("DialogueForm").submit();
	}
]]></Implementation>
</Method>
</Class>


<Class name="User.SourceControl.Git.Hooks">
<Description><![CDATA[
<a href="http://www.readycomputing.com/">
<img src="http://www.readycomputing.com/images/header/headerLogo.png" alt="Ready Computing" >
</a>
<br>]]></Description>
<IncludeCode>Ensemble</IncludeCode>
<Super>%Studio.Extension.Base</Super>
<TimeChanged>65289,52360.683295</TimeChanged>
<TimeCreated>62655,58027.787011</TimeCreated>

<UDLText name="T">
<Content><![CDATA[
// RC: Add Name="%Separator" for all separators

]]></Content>
</UDLText>

<XData name="Menu">
<Data><![CDATA[
<MenuBase>
<Menu Name="Source Control Context Menu" Type="0">
<MenuItem Name="Check Out"/>
<MenuItem Name="Check In"/>
<MenuItem Name="Add To"/>
<MenuItem Name="Remove From"/>
</Menu>
<Menu Name="%SourceMenuContext" Type="1">
<MenuItem Name="Check Out"/>
<MenuItem Name="Check In"/>
<MenuItem Name="Add To"/>
<MenuItem Name="Remove From"/>
</Menu>
<Menu Name="Source Control Main Menu" Type="0">
<MenuItem Name="Settings" />
<MenuItem Name="Clone Repository" Save = "001"/>
<MenuItem Name="%Separator" Separator="true"/>
<MenuItem Name="Current Branch" Save = "001"/>
<MenuItem Name="Switch to Branch" Save = "001"/>
<MenuItem Name="Status" Save = "001"/>
<MenuItem Name="%Separator" Separator="true"/>
<MenuItem Name="Commit" Save = "001"/>
<MenuItem Name="Pull" Save = "001"/>
<MenuItem Name="Push" Save = "001"/>
<MenuItem Name="%Separator" Separator="true"/>
<MenuItem Name="Create Feature Branch" Save = "001"/>
<MenuItem Name="Create Release Branch" Save = "001"/>
<MenuItem Name="%Separator" Separator="true"/>
<MenuItem Name="Pull from Develop" Save = "001"/>
<MenuItem Name="Pull from Team" Save = "001"/>
<MenuItem Name="Diff with Team" Save = "001"/>
<MenuItem Name="Merge to Team and Delete" Save = "001"/>
<MenuItem Name="%Separator" Separator="true"/>
<MenuItem Name="Resolve Merge Conflicts" Save = "001"/>
</Menu>

</MenuBase>
]]></Data>
</XData>

<Method name="UserAction">
<FormalSpec><![CDATA[Type:%Integer,Name:%String,InternalName:%String,SelectedText:%String,&Action:%String,&Target:%String,&Msg:%String,&Reload:%Boolean]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	
	#dim ec As %Status = $$$OK
	#dim menu As %Status = $Piece(Name, ",", 1)
	if menu '= "Source Control Context Menu",menu '= "Source Control Main Menu", menu'="%SourceMenuContext" {
		Quit $$$OK
	}
	s ec = ##class(User.SourceControl.Git.Utils).UserAction(InternalName, Name, .Target, .Action, .Reload)
	Quit ec
]]></Implementation>
</Method>

<Method name="OnSourceMenuItem">
<FormalSpec><![CDATA[name:%String,&Enabled:%String,&DisplayName:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	//RC: Adding separator
	if name = "%Separator" {
		s DisplayName = ""
		s Enabled = 0
		Quit $$$OK
	}
	//RC:
	if name = "Settings" {
		// We always show Settings
		Quit $$$OK
	} 
	
	if ##class(User.SourceControl.Git.Utils).NeedSettings() {
		s Enabled = -1
		Quit $$$OK
	} 
	
	if ##class(User.SourceControl.Git.Utils).IsNamespaceInGit() {
		if name = "Clone Repository" {
			s Enabled = 0
		} elseif name = "Current Branch" {
			s DisplayName = "Current Branch: "_##class(User.SourceControl.Git.Utils).CurrentBranch()
			s Enabled = 0
		} elseif name = "Resolve Merge Conflicts" {
			s Enabled = 1
		} elseif name = "Create Feature Branch" {
			s tCurrentBranch = ##class(User.SourceControl.Git.Utils).CurrentBranch()
			if tCurrentBranch'=##class(User.SourceControl.Git.Utils).TeamBranch() s Enabled = 0
		} elseif name = "Create Release Branch" {
			s tCurrentBranch = ##class(User.SourceControl.Git.Utils).CurrentBranch()
			if $F($ZCVT(tCurrentBranch,"U"),"DEVELOP")=0 s Enabled = 0
		} elseif ##class(User.SourceControl.Git.Utils).IsFeatureMenuGitCommand(name) {
			s tCurrentBranch = ##class(User.SourceControl.Git.Utils).CurrentBranch()
			if $F($ZCVT(tCurrentBranch,"U"),"FEATURE/")=0 s Enabled = 0
		} elseif ##class(User.SourceControl.Git.Utils).IsMenuGitCommand(name) {
			//This else should be last to allow for special handling of menugitcommands as needed
			s Enabled = 1
		} else {
			s Enabled = -1
		}
	} else { 
		if name '= "Clone Repository" {
			s Enabled = -1
		}
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnSourceMenuContextItem">
<FormalSpec><![CDATA[itemName:%String,menuItemName:%String,&Enabled:%String,&DisplayName:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	if (itemName = "") 
	|| '##class(User.SourceControl.Git.Utils).IsNamespaceInGit() 
	|| (##class(User.SourceControl.Git.Utils).Type(itemName)="pkg") {
		s Enabled = -1
		Quit $$$OK
	}
	
	s tIsCheckedOut = ##class(User.SourceControl.Git.Utils).IsCheckedOut(itemName,.tUserName) 
	s tIsStaged = ##class(User.SourceControl.Git.Utils).IsStaged(itemName) //check to see if file has uncommitted changes
	
	if ##class(User.SourceControl.Git.Utils).IsInSourceControl(itemName) {
		if menuItemName="Add To" Set Enabled = -1
		//If it is in SC, then it may be checked out to someone else - only allow remove by the person locking the item
		if (menuItemName="Remove From") && tIsCheckedOut {
			if tUserName = $USERNAME {
				Set Enabled = 1
			} elseif $System.Security.Check("AH_SourceControlAdmin","USE") {
				Set Enabled = 1
			} else {
				Set Enabled = -1
			}
		} elseIf menuItemName="Remove From" {
			Set Enabled = 1
		}
	} else {
		if menuItemName="Add To" Set Enabled = 1
		if menuItemName="Remove From" Set Enabled = -1
	}
	
	if tIsCheckedOut {
		if menuItemName="Check Out" Set Enabled = -1
		if (menuItemName="Check In") && (tIsStaged=0) {
			if tUserName = $USERNAME {
				Set Enabled = 1
			} elseif $System.Security.Check("AH_SourceControlAdmin","USE") {
				Set Enabled = 1
			} else {
				Set Enabled = -1
			}
		} elseif (menuItemName="Check In") && (tIsStaged=1) {
			Set Enabled = -1
		}
	} else {
		if menuItemName="Check In" Set Enabled = -1
	}
	
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnMenuItem">
<Description><![CDATA[
This is called for every menu item returned to Studio to allow the menu to be enabled/disabled without
having to write a custom query for <query>MenuItems</query>. The <var>DisplayName</var> of this menu is
also passed by reference and this may be modified to change the appearance of this menu item. The <var>MenuName</var>
is the main menu name then the submenu name separated by a ','. If <var>Enabled</var> is set to -1 then it will remove
this menu item from the list totally, 0 will gray the menu item out and the default 1 will display the menu item as normal.]]></Description>
<FormalSpec><![CDATA[MenuName:%String,InternalName:%String,SelectedText:%String,&Enabled:%Boolean,&DisplayName:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim menu As %String= $piece(MenuName,",")
	#dim name As %String = $piece(MenuName,",",2)
	
#;	s tTime=$H
#;	s tInt=$I(^MS(tTime))
#;	s ^MS(tTime,tInt,"MenuName")=MenuName
#;	s ^MS(tTime,tInt,"InternalName")=InternalName
#;	s ^MS(tTime,tInt,"SelectedText")=SelectedText
#;	s ^MS(tTime,tInt,"Enabled")=Enabled
#;	s ^MS(tTime,tInt,"DisplayName")=DisplayName
#;	s ^MS(tTime,tInt,"this")=$THIS
#;	s ^MS(tTime,tInt,"StudioVersion")=$THIS.StudioVersion
	
	if menu = "%SourceMenuContext", name = "" {
		s DisplayName = "&SourceControl"
	}
	if menu = "Source Control Main Menu", name = "" {
		s DisplayName = "&SourceControl"
	}
	if menu = "Source Control Context Menu" {
		if $THIS.StudioVersion'="" {
			s Enabled=0
			s DisplayName=""
		} else {
			if name '= "" {
				s ec = ..OnSourceMenuContextItem(InternalName, name, .Enabled, .DisplayName)
			}
		}
	}
	#dim ec As %Status = $$$OK

	if menu = "Source Control Main Menu" {
		s ec = ..OnSourceMenuItem(name, .Enabled, .DisplayName)
	}elseif menu = "%SourceMenuContext" {
		s ec = ..OnSourceMenuContextItem(InternalName, name, .Enabled, .DisplayName)
	}
	Quit ec
]]></Implementation>
</Method>

<Method name="IsReadOnly">
<Description>
Return true if this item should be marked as read only.
This is called when Studio opens a document. It is set to indicate
that the user checked the 'read only' checkbox in the open
dialog in Studio.</Description>
<FormalSpec>InternalName:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	//w !,"isreadonly: "_InternalName
	
	#dim tReadOnly As %Boolean = 0
	
	//if ##class(User.SourceControl.Git.Utils).IsInSourceControl(InternalName) {
		s tCurrentBranch = ##class(User.SourceControl.Git.Utils).CurrentBranch()
		if $F($ZCVT(tCurrentBranch,"U"),"FEATURE/")=0 Set tReadOnly = 1
	//}
	
	Quit tReadOnly
]]></Implementation>
</Method>

<Method name="OnBeforeLoad">
<Description>
This is called before the actual load of data to give the chance
to load the item from an external format.</Description>
<FormalSpec>InternalName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tSC As %Status = $$$OK
	
	//w !,"onbeforeload: "_InternalName
	if ##class(User.SourceControl.Git.Utils).IsInSourceControl(InternalName) {
		If ##class(User.SourceControl.Git.Utils).IsCheckedOut(InternalName,.tUserName) {
			if tUserName '= $USERNAME {
				//Item is checked out by a different user - warn the user that changes cannot be saved (is there a way to make it read only?)
				Write !,"This item is checked out by another user.  Currently checked out by: "_tUserName
				Write !,"Item is opened as Read Only."
				//This may not be good enough - perhaps we need a popup?
				
				if $THIS.StudioVersion="" {
					Set tSC = $$$ERROR($$$GeneralError,"This item is checked out by another user.  Currently checked out by: "_tUserName)
				}
				
			}
		}
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="OnBeforeSave">
<Description>
Called before the item is saved to the Cache database it is passed
a reference to the current temporary storage of this item so that it
can be modified before the save completes. If you quit with an error
value then it will abort the save.</Description>
<FormalSpec>InternalName:%String,Location:%String="",Object:%RegisteredObject=$$$NULLOREF</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	//w !,"onbeforesave: "_InternalName
	#dim tSC As %Status = $$$OK
	if ##class(User.SourceControl.Git.Utils).IsInSourceControl(InternalName) {
		If ##class(User.SourceControl.Git.Utils).IsCheckedOut(InternalName,.tUserName) {
			if tUserName '= $USERNAME {
				//Item is checked out by a different user - Quit with an error to abort the save
				s tSC = $System.Status.Error($$$GeneralError,"Item is locked by another user: "_tUserName)
			}
		}
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="OnAfterSave">
<Description>
This is called after the item has been saved to the database.
It may be passed a reference to the object representing the item
just saved. It can be use to export this documement to an external form for example.</Description>
<FormalSpec>InternalName:%String,Object:%RegisteredObject=$$$NULLOREF</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	//w !,"onaftersave:  "_InternalName
	
	if ##class(User.SourceControl.Git.Utils).IsNamespaceInGit() {
		If '##class(User.SourceControl.Git.Utils).IsInSourceControl(InternalName) {
			//Always add new files to source control by default
			s tSC = ##class(User.SourceControl.Git.Utils).AddToSourceControl(InternalName)
			Quit tSC
		} else {
			$$$QuitOnError(##class(User.SourceControl.Git.Utils).RemoveRoutineTSH(InternalName))
			s tSC = ##class(User.SourceControl.Git.Utils).ExportItem(InternalName)
			Q:$$$ISERR(tSC) tSC
			s tSC = ##class(User.SourceControl.Git.Utils).CheckOutItem(InternalName)
			Quit tSC
		}
	} else {
		Quit $$$OK
	}
]]></Implementation>
</Method>

<Method name="AddToSourceControl">
<FormalSpec>InternalName,pInfo</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	//the Ens.Deployment.Utils calls this method on the Hooks class by default
	//By quitting $$$OK we do not take action when the deployment util is used
	//Instead, we rely on the hooks - onaftersave, etc as per normal
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnAfterDelete">
<Description>
Called after an item is deleted.</Description>
<FormalSpec>InternalName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	if ##class(User.SourceControl.Git.Utils).IsInSourceControl(InternalName) {
		Quit ##class(User.SourceControl.Git.Utils).DeleteExternalFile(InternalName)
	}
	Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="User.SourceControl.Git.MergeConflicts">
<Description><![CDATA[
<a href="http://www.readycomputing.com/">
<img src="http://www.readycomputing.com/images/header/headerLogo.png" alt="Ready Computing" >
</a>
<br/>
Source control settings page]]></Description>
<IncludeCode>HS.Common</IncludeCode>
<Super>HS.UI.Template,User.SourceControl.Git.Utils</Super>
<TimeChanged>65288,56506.194007</TimeChanged>
<TimeCreated>63685,58313.468979</TimeCreated>
<DependsOn>HS.UI.Custom.tablePane,HS.UI.Custom.tabGroup</DependsOn>

<Parameter name="RESOURCE">
<Description>
Security requirement</Description>
<Default>AH_SourceControl</Default>
</Parameter>

<Property name="PageTitle">
<Description>
Page title</Description>
<Type>%ZEN.Datatype.caption</Type>
<InitialExpression>$$$TextHTML("Source Control Settings")</InitialExpression>
</Property>

<XData name="Style">
<Description>
This Style block contains page-specific CSS style definitions.</Description>
<Data><![CDATA[
<style type="text/css">
	
	a.link:visited {
		color: black;
		font-family: tahoma,arial,verdana;
    	font-size: 12px;
    	text-decoration: none;
	}
	a.link:hover {
		background-color: LightGray;
	}
	a.link {
		color: black;
		font-family: tahoma,arial,verdana;
    	font-size: 12px;
    	text-decoration: none;
	}
	
	.linkDisabled {
		color: gray;
		font-family: tahoma,arial,verdana;
    	font-size: 12px;
    	text-decoration: none;
	}

</style>
]]></Data>
</XData>

<XData name="detailPane">
<Description>
This XML block defines the contents of this page.</Description>
<XMLNamespace>http://www.intersystems.com/zen</XMLNamespace>
<Data><![CDATA[
<pane xmlns="http://www.intersystems.com/zen" title="Settings">

<html id="Output" hidden="false" OnDrawContent="DrawOutput"/>
<html id="gitOutput" hidden="true"/>

</pane>
]]></Data>
</XData>

<Method name="DrawOutput">
<FormalSpec>seed:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tSC As %Status = $$$OK
	#dim e As %Exception.AbstractException
	
	Try {
		
		s tCommand = ..GitCmdPrefix()
		s tCommand = tCommand_" status"
		s tSC = ..RunCmd(tCommand,.tOutput,0) $$$ThrowOnError(tSC)

		Set ..%GetComponentById("Output").hidden=0
		
		s tMergeConflict=0
		for i=1:1:tOutput {
			s tOutputLine = tOutput(i)
			if $ZCVT(tOutputLine,"L") [ "unmerged" s tMergeConflict = 1
			&html<
				#(tOutputLine)#
				<br>
			>
		}
		
		Kill tOutput
		s tCommand = ..GitCmdPrefix()
		s tCommand = tCommand_" status -s"
		s tSC = ..RunCmd(tCommand,.tOutput,0) $$$ThrowOnError(tSC)
		&html<
			<br>
			Unmerged Files:
			<br>
		>
		for i=1:1:tOutput {
			s tOutputLine = tOutput(i)
			if $E(tOutputLine,1,2) [ "U" {
				
			}
			&html<
				#(tOutputLine)#
				<br>
			>
		}
		
		
		
	} catch e {
		s tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%OnAfterCreatePage">
<Description><![CDATA[
This callback is called after the server-side page 
object and all of its children are created.<br/>
Subclasses can override this to add, remove, or modify 
items within the page object model, or to provide values
for controls.]]></Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="runGitCommand">
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var User = zenPage.getComponentById('cmbGitUsers').getValue();
	var Command = zenPage.getComponentById('gitCommand').getValue();
	
	var ok = this.HandleGitCommand(User,Command);
]]></Implementation>
</Method>

<Method name="HandleGitCommand">
<ClassMethod>1</ClassMethod>
<FormalSpec>pUser,pCommand</FormalSpec>
<ReturnType>%String</ReturnType>
<ZenMethod>1</ZenMethod>
<Implementation><![CDATA[
	
	#dim tSC As %Status = $$$OK
	#dim e As %Exception.AbstractException
	#dim tReturn As %String = 1
	
	Try {
		s tGitCommand = "git -C "_^Git("%user",pUser,"%repositoryFolder")_" "
		s tGitCommand = tGitCommand_pCommand
		s tSC = ##class(User.SourceControl.Git.Utils).RunCmd(tGitCommand,.tOutput,0)
		s tHTML="<br/>"
		if tSC {
			for i=1:1:tOutput {
				s tHTML = tHTML_tOutput(i) _"<br/>"
			}
		} else {
			s tHTML=$System.Status.GetErrorText(tSC)
		}

		&js< zenPage.getComponentById('gitOutput').setProperty('content','#($ZCVT(tHTML,"O","JS"))#');>
		
	} catch e {
		s tReturn = e.DisplayString()
	}
	Quit tReturn
]]></Implementation>
</Method>

<Parameter name="SrcVer">
<Description>
Revision number of this class</Description>
<Default>2</Default>
</Parameter>
</Class>


<Class name="User.SourceControl.Git.Setting">
<Description><![CDATA[
<a href="http://www.readycomputing.com/">
<img src="http://www.readycomputing.com/images/header/headerLogo.png" alt="Ready Computing" >
</a>
<br/>
Source control settings page]]></Description>
<IncludeCode>HS.Common</IncludeCode>
<Super>HS.UI.Template</Super>
<TimeChanged>65288,48865.937536</TimeChanged>
<TimeCreated>63685,58313.468979</TimeCreated>
<DependsOn>HS.UI.Custom.tablePane,HS.UI.Custom.tabGroup</DependsOn>

<Parameter name="RESOURCE">
<Description>
Security requirement</Description>
<Default>AH_SourceControl</Default>
</Parameter>

<Property name="PageTitle">
<Description>
Page title</Description>
<Type>%ZEN.Datatype.caption</Type>
<InitialExpression>$$$TextHTML("Source Control Settings")</InitialExpression>
</Property>

<XData name="Style">
<Description>
This Style block contains page-specific CSS style definitions.</Description>
<Data><![CDATA[
<style type="text/css">
	
	a.link:visited {
		color: black;
		font-family: tahoma,arial,verdana;
    	font-size: 12px;
    	text-decoration: none;
	}
	a.link:hover {
		background-color: LightGray;
	}
	a.link {
		color: black;
		font-family: tahoma,arial,verdana;
    	font-size: 12px;
    	text-decoration: none;
	}
	
	.linkDisabled {
		color: gray;
		font-family: tahoma,arial,verdana;
    	font-size: 12px;
    	text-decoration: none;
	}

</style>
]]></Data>
</XData>

<XData name="detailPane">
<Description>
This XML block defines the contents of this page.</Description>
<XMLNamespace>http://www.intersystems.com/zen</XMLNamespace>
<Data><![CDATA[
<pane xmlns="http://www.intersystems.com/zen" title="Settings">
<fieldSet legend="Settings">
<form labelPosition="left" OnSubmitForm="SubmitForm">
<spacer height="20"/>
<text id="userName" name="userName" label="Repository username:" title="BitBucket or other Repo username" required="true" size="100"/>
<text id="personName" name="personName" label="Your Name:" title="Your Name" required="true" size="100"/>
<text id="personEmail" name="personEmail" label="Your Email:" title="you@example.com" required="true" size="100"/>
<text id="teamBranch" name="teamBranch" label="Team Branch:" title="example: team-dev/teamA" required="true" size="100"/>
<text id="repoProtocol" name="repoProtocol" label="Repository Protocol:" title="http or https" required="true" size="100"/>
<text id="repoURL" name="repoURL" label="Repository URL:" title="(e.g. c:\temp)" required="true" size="100"/>
<text id="repoBaseFolder" name="repoBaseFolder" label="Base path for all user's repositories:" title="(e.g. c:\temp)" required="true" size="100"/>
<submit caption="Save"/>
</form>
</fieldSet>
<spacer height="20"/>
<fieldSet legend="Actions">
<spacer height="20"/>
<link id="CloneLink" href="User.SourceControl.Git.Dialogue.cls?UserAction=Clone Repository" disabled="true" caption="Clone Repository" target="_self" />
<link id="StatusLink" href="User.SourceControl.Git.Dialogue.cls?UserAction=Status" disabled="true" caption="Status" target="_self" />
<link id="CommitLink" href="User.SourceControl.Git.Dialogue.cls?UserAction=Commit" disabled="true" caption="Commit" target="_self" />
<spacer height="20"/>
</fieldSet>
<fieldSet id="fsGit" hidden="true" legend="Git">
<combobox id="cmbGitUsers" label="User" size="35" disabled="false" editable="false" >
</combobox>
<text id="gitCommand" name="gitComand" label="Git Command" size="100" hint="(Enter git command without 'git'.  example: 'status')"/>
<button id="btnGitCommand" name="btnGitCommand" caption="Run" onclick="zenPage.runGitCommand();" />
<link caption="Git Documentation" href="https://git-scm.com/docs" target="_blank" style="color: blue;"/>
<html id="gitOutput"/>
</fieldSet>
</pane>
]]></Data>
</XData>

<Method name="SubmitForm">
<Description>
Callback to process values submitted for form.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pSubmit:%ZEN.Submit</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	
	#dim tSettings As %String
	Set tSettings("repoBaseFolder")=pSubmit.%GetValue("repoBaseFolder")
	Set tSettings("userName")=pSubmit.%GetValue("userName")
	Set tSettings("repoURL")=pSubmit.%GetValue("repoURL")
	Set tSettings("repoProtocol")=pSubmit.%GetValue("repoProtocol")
	Set tSettings("personName")=pSubmit.%GetValue("personName")
	Set tSettings("personEmail")=pSubmit.%GetValue("personEmail")
	Set tSettings("teamBranch")=pSubmit.%GetValue("teamBranch")
	d ##class(User.SourceControl.Git.Utils).UpdateSettings(.tSettings)
	QUIT $$$OK
]]></Implementation>
</Method>

<Method name="%OnAfterCreatePage">
<Description><![CDATA[
This callback is called after the server-side page 
object and all of its children are created.<br/>
Subclasses can override this to add, remove, or modify 
items within the page object model, or to provide values
for controls.]]></Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	//Set tCtrl=..%GetComponentById("gitBinPath")
	//Set tCtrl.value=##class(User.SourceControl.Git.Utils).GitBinPath()

	Set tCtrl=..%GetComponentById("repoBaseFolder")
	Set tCtrl.value=##class(User.SourceControl.Git.Utils).RepoBaseFolder()
	if '$System.Security.Check("AH_SourceControlAdmin","USE") Set tCtrl.disabled = 1
	
	Set tCtrl=..%GetComponentById("userName")
	Set tCtrl.value=##class(User.SourceControl.Git.Utils).UserName()
	
	Set tCtrl=..%GetComponentById("repoProtocol")
	Set tCtrl.value=##class(User.SourceControl.Git.Utils).RepoProtocol()
	if '$System.Security.Check("AH_SourceControlAdmin","USE") Set tCtrl.disabled = 1
	
	Set tCtrl=..%GetComponentById("repoURL")
	Set tCtrl.value=##class(User.SourceControl.Git.Utils).RepoURL()
	if '$System.Security.Check("AH_SourceControlAdmin","USE") Set tCtrl.disabled = 1

	Set tCtrl=..%GetComponentById("personName")
	Set tCtrl.value=##class(User.SourceControl.Git.Utils).PersonName()
	
	Set tCtrl=..%GetComponentById("personEmail")
	Set tCtrl.value=##class(User.SourceControl.Git.Utils).PersonEmail()
	
	Set tCtrl=..%GetComponentById("teamBranch")
	Set tCtrl.value=##class(User.SourceControl.Git.Utils).TeamBranch()
	
	if '##class(User.SourceControl.Git.Utils).NeedSettings() {
		if '##class(User.SourceControl.Git.Utils).IsNamespaceInGit() {
			Set tCtrl=..%GetComponentById("CloneLink")
			Set tCtrl.disabled = 0
		} else {
			Set tCtrl=..%GetComponentById("StatusLink")
			Set tCtrl.disabled = 0
			Set tCtrl=..%GetComponentById("CommitLink")
			Set tCtrl.disabled = 0
			
		}
	}
	
	if $System.Security.Check("AH_SourceControlAdmin","USE") {
		//This feature allows any admin to run any git command against any local repository!
		Set tFS=..%GetComponentById("fsGit")
		Set tFS.hidden = 0
		
		s tUserList=""
		s tUser=""
		For { s tUser = $O(^Git("%user",tUser)) Q:tUser=""
			s tUserList = tUserList_","_tUser
		}
		Set tCombo=..%GetComponentById("cmbGitUsers")
		Set tCombo.displayList = tUserList
		Set tCombo.valueList = tUserList
		
	}
		
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="runGitCommand">
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var User = zenPage.getComponentById('cmbGitUsers').getValue();
	var Command = zenPage.getComponentById('gitCommand').getValue();
	
	var ok = this.HandleGitCommand(User,Command);
]]></Implementation>
</Method>

<Method name="HandleGitCommand">
<ClassMethod>1</ClassMethod>
<FormalSpec>pUser,pCommand</FormalSpec>
<ReturnType>%String</ReturnType>
<ZenMethod>1</ZenMethod>
<Implementation><![CDATA[
	
	#dim tSC As %Status = $$$OK
	#dim e As %Exception.AbstractException
	#dim tReturn As %String = 1
	
	Try {
		s tGitCommand = "git -C "_^Git("%user",pUser,"%repositoryFolder")_" "
		s tGitCommand = tGitCommand_pCommand
		s tSC = ##class(User.SourceControl.Git.Utils).RunCmd(tGitCommand,.tOutput,0)
		s tHTML="<br/>"
		if tSC {
			for i=1:1:tOutput {
				s tHTML = tHTML_tOutput(i) _"<br/>"
			}
		} else {
			s tHTML=$System.Status.GetErrorText(tSC)
		}

		&js< zenPage.getComponentById('gitOutput').setProperty('content','#($ZCVT(tHTML,"O","JS"))#');>
		
	} catch e {
		s tReturn = e.DisplayString()
	}
	Quit tReturn
]]></Implementation>
</Method>

<Parameter name="SrcVer">
<Description>
Revision number of this class</Description>
<Default>2</Default>
</Parameter>
</Class>


<Class name="User.SourceControl.Git.Utils">
<Description><![CDATA[
<a href="http://www.readycomputing.com/">
<img src="http://www.readycomputing.com/images/header/headerLogo.png" alt="Ready Computing" >
</a> 
<br/>]]></Description>
<Abstract>1</Abstract>
<IncludeCode>%occStatus</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<TimeChanged>65365,40095.515701</TimeChanged>
<TimeCreated>62657,53384.637236</TimeCreated>

<Parameter name="Storage">
<Default>^Git</Default>
</Parameter>

<Parameter name="UseUDL">
<Default>1</Default>
</Parameter>

<Parameter name="NOTUDLEXTENSIONS">
<Description>
Extensions that can not be exported as UDL. XML will always be used.</Description>
<Expression>$lb("hl7","dfi","lut")</Expression>
</Parameter>

<Parameter name="InstallNamespace">
<Default>HSCUSTOM</Default>
</Parameter>

<Parameter name="IsSYNC">
<Description><![CDATA[
If equals to 0 all tortoise-git calls are asynchronous<br/>
Otherwise calls are synchronous and import is automatically executed after git calls.]]></Description>
<Default>0</Default>
</Parameter>

<Parameter name="GitMenuItems">
<Description>
Git menu commands</Description>
<Default>,Clone Repository,Status,Create Feature Branch,Create Release Branch,Pull,Switch to Branch,</Default>
</Parameter>

<Parameter name="GitFeatureMenuItems">
<Description>
Menu Items that show, but are only enabled when on a Feature branch.</Description>
<Default>,Commit,Push,Pull from Develop,Pull from Team,Diff with Team,Merge to Team and Delete,</Default>
</Parameter>

<Parameter name="GitContextMenuItems">
<Description>
RC: Removed %Blame,</Description>
<Default>,</Default>
</Parameter>

<Method name="InstallNamespaceStorage">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$Replace(..#Storage,"^","^["""_..#InstallNamespace_"""]")
]]></Implementation>
</Method>

<Method name="RepoFolder">
<Description>
Returns root temp folder</Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$G(@..InstallNamespaceStorage()@("%user",$USERNAME,"%repositoryFolder"))
]]></Implementation>
</Method>

<Method name="UserName">
<Description>
Returns stored repository username</Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$G(@..InstallNamespaceStorage()@("%user",$USERNAME,"%userName"))
]]></Implementation>
</Method>

<Method name="PersonName">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$G(@..InstallNamespaceStorage()@("%user",$USERNAME,"%personName"))
]]></Implementation>
</Method>

<Method name="PersonEmail">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$G(@..InstallNamespaceStorage()@("%user",$USERNAME,"%personEmail"))
]]></Implementation>
</Method>

<Method name="TeamBranch">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$G(@..InstallNamespaceStorage()@("%user",$USERNAME,"%teamBranch"))
]]></Implementation>
</Method>

<Method name="RepoURL">
<Description>
Returns root temp folder</Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$G(@..InstallNamespaceStorage()@("%repoURL"))
]]></Implementation>
</Method>

<Method name="RepoBaseFolder">
<Description>
Returns root temp folder</Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$G(@..InstallNamespaceStorage()@("%repoBaseFolder"))
]]></Implementation>
</Method>

<Method name="RepoName">
<Description>
Returns root temp folder</Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$G(@..InstallNamespaceStorage()@("%repoName"))
]]></Implementation>
</Method>

<Method name="RepoProtocol">
<Description>
Returns root temp folder</Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$G(@..InstallNamespaceStorage()@("%repoProtocol"))
]]></Implementation>
</Method>

<Method name="GitCmdPrefix">
<Description>
Returns default git command prefix</Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["git -C "_..RepoFolder()
]]></Implementation>
</Method>

<Method name="MakeError">
<Description>
8012 because this error has corresponding error message</Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>msg:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[$$$ERROR(8012,"Git",msg)
]]></Implementation>
</Method>

<Method name="NeedSettings">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[(..RepoFolder() = "") ||  (..RepoURL() = "") ||  (..RepoProtocol() = "") ||  (..UserName() = "")
]]></Implementation>
</Method>

<Method name="InstallNamespace">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[..#InstallNamespace
]]></Implementation>
</Method>

<Method name="CurrentBranch">
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	s tCurrentBranch=""
	s tCommand = ..GitCmdPrefix()
	s tCommand = tCommand_" branch"
	s tDisplay = 0
	s tSC = ..RunCmd(tCommand,.tOutput,tDisplay)
	if $$$ISERR(tSC) Quit "error"
	For i=1:1:tOutput {
		s tOutputLine = tOutput(i)
		if $E(tOutputLine,1,1) = "*" {
			s tCurrentBranch=$E(tOutputLine,3,*)
		}		
	}
	Quit tCurrentBranch
]]></Implementation>
</Method>

<Method name="BranchList">
<ClassMethod>1</ClassMethod>
<FormalSpec>pIncludeReleaseBranches:%Boolean=0,pIncludeRemote:%Boolean=1</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	//Always include develop and team brances
	s tTeamBranch = ..TeamBranch()
	s tBranchList=",develop,"_tTeamBranch
	
	//Get a list of feature branches both local and remote as per paremeter
	s tCommand = ..GitCmdPrefix()
	s tCommand = tCommand_" branch"
	If pIncludeRemote s tCommand = tCommand_" --list -a"
	s tDisplay = 0
	s tSC = ..RunCmd(tCommand,.tOutput,tDisplay)
	if $$$ISERR(tSC) Quit "error"
	For i=1:1:tOutput {
		s tBranch = $REPLACE($E(tOutput(i),3,*),"remotes/origin/","")
		if tBranchList_"," '[ (tBranch_",") {
			if $E(tBranch,1,8)="feature/" {
				kill tOutputCheckout
				s tCommand = ..GitCmdPrefix()_" checkout "_tBranch
				s tSC = ..RunCmd(tCommand,.tOutputCheckout,tDisplay)
				if $$$ISERR(tSC) Quit
				
				kill tOutputInitialCommit
				s tCommand = ..GitCmdPrefix()_" log --grep=""Initial commit"" --oneline --decorate"
				s tSC = ..RunCmd(tCommand,.tOutputInitialCommit,tDisplay)
				if $$$ISERR(tSC) Quit
				
				s tInitialCommit = $G(tOutputInitialCommit(1))
				if tInitialCommit [ tTeamBranch {
					s tBranchList=tBranchList_","_tBranch
				}
			}
		}
	}
	if $$$ISERR(tSC) Quit "error"
	Quit tBranchList
]]></Implementation>
</Method>

<Method name="UpdateSettings">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&settings]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  
    // set user properties - username and password to start with.
    s @..InstallNamespaceStorage()@("%user",$USERNAME,"%userName") = settings("userName")
    s @..InstallNamespaceStorage()@("%user",$USERNAME,"%personName") = settings("personName")
    s @..InstallNamespaceStorage()@("%user",$USERNAME,"%personEmail") = settings("personEmail")
    s @..InstallNamespaceStorage()@("%user",$USERNAME,"%teamBranch") = $G(settings("teamBranch"))
    
    If $System.Security.Check("AH_SourceControlAdmin","USE") {    
	    // set Repository url - example: bitbucket.org/readycomputinginc/alohr.git
	    s @..InstallNamespaceStorage()@("%repoURL") = settings("repoURL")
	    s @..InstallNamespaceStorage()@("%repoProtocol") = settings("repoProtocol")
	    s @..InstallNamespaceStorage()@("%repoName") = $P($P(settings("repoURL"),"/",$L(settings("repoURL"),"/")),".",1)
	    // set Repository url - example: bitbucket.org/readycomputinginc/alohr.git
	    s @..InstallNamespaceStorage()@("%repoBaseFolder") = ##class(%File).NormalizeDirectory(settings("repoBaseFolder"))
    }    
    //Build user's repo folder using the base folder, username, and repository name
    s tFolder = ##class(%File).NormalizeDirectory(..RepoBaseFolder()_$USERNAME_"\"_..RepoName())
    s @..InstallNamespaceStorage()@("%user",$USERNAME,"%repositoryFolder") = tFolder
]]></Implementation>
</Method>

<Method name="HandleDialogue">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pSettings,&pOutput]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	
	#dim tSC As %Status = $$$OK
	#dim e As %Exception.AbstractException
	
	Try {
		
		s tCommandName = $O(pSettings(""))
		
		s tCommand = ..GitCmdPrefix()
		
		if tCommandName = "Clone Repository" {
			
			//Don't display clone command with password
			s tDisplay=0
			
			s tFolder = ##class(%File).ParentDirectoryName(..RepoFolder())
			s tRepoFolder = ..RepoFolder()
			s tSC = ##class(%File).CreateDirectoryChain(tRepoFolder)
			if 'tSC $$$ThrowOnError(..MakeError("unable to create folder: "_tRepoFolder))
			
			//For clone only, execute command at one level up from repofolder
			s tCommand = "git -C "_tFolder
			s tPassword = $REPLACE(pSettings(tCommandName),"""","\""")
			s tPassword = $ZCVT(tPassword,"O","URL")
			s tCommand = tCommand_" clone """_..RepoProtocol()_"://"_..UserName()_":"_tPassword_"@"_..RepoURL()_""""
			
			s tSC = ..RunCmd(tCommand,.pOutput,tDisplay) $$$ThrowOnError(tSC)
			
			s pOutput($I(pOutput))="-------------------------------"
						
			s tCommand = ..GitCmdPrefix()
			s tCommand = tCommand_" config user.name """_..PersonName()_""""
			s tSC = ..RunCmd(tCommand,.pOutput) $$$ThrowOnError(tSC)
			
			s tCommand = ..GitCmdPrefix()
			s tCommand = tCommand_" config user.email """_..PersonEmail()_""""
			s tSC = ..RunCmd(tCommand,.pOutput) $$$ThrowOnError(tSC)
			
			s tCommand = ..GitCmdPrefix()
			s tCommand = tCommand_" checkout master"
			
		} elseif tCommandName = "Status" {
			s tCommand = tCommand_" status"
		} elseif tCommandName="Switch to Branch" {
			s tCommand = tCommand_" checkout "_pSettings(tCommandName)
		} elseif tCommandName = "ListDiff" {
			//ListDiff compares the current HEAD (last commit on current branch) to a target branch.  Used to evaluate completeness of release branch.
			s tCommand = tCommand_" diff --name-only HEAD "_pSettings(tCommandName)
		} elseif tCommandName = "Commit" {
			s tCommand = tCommand_" commit -m """_$TR(pSettings(tCommandName),"'","")_""""
	//disabling the auto push at this time
#;			s tSC = ..RunCmd(tCommand,.pOutput) $$$ThrowOnError(tSC)
#;			s pOutput($I(pOutput))="-------------------------------"
#;			s tCommand = ..GitCmdPrefix()
#;			s tCommand = tCommand_" pull --rebase"
#;			s tSC = ..RunCmd(tCommand,.pOutput) $$$ThrowOnError(tSC)
#;			s pOutput($I(pOutput))="-------------------------------"
#;			s tCommand = ..GitCmdPrefix()
#;			s tCommand = tCommand_" push"
		} elseif tCommandName = "Pull" {
			s tCommand = tCommand_" pull --rebase"
		} elseif tCommandName = "Add" {
			s tCommand = tCommand_" add ."
		} elseif tCommandName = "Push" {
			s tCommand = tCommand_" push"
		} elseif tCommandName = "Create Feature Branch" {
			//consider adding checkbox to allow push to be optional, but currently it is default behavior
			//should add syntax checking for branch names
			s tBranchName = pSettings(tCommandName)
			if '$FIND(tBranchName,"feature/") s tBranchName = "feature/"_tBranchName
			s tCreateBranchCommand = tCommand_" checkout -b "_tBranchName
			s tSC = ..RunCmd(tCreateBranchCommand,.pOutput) $$$ThrowOnError(tSC)
			s tCommand = tCommand_" push --set-upstream origin "_tBranchName
		} elseif tCommandName = "Create Release Branch" {
			//consider adding checkbox to allow push to be optional, but currently it is default behavior
			//should add syntax checking for branch names
			s tBranchName = pSettings(tCommandName)
			if '$FIND(tBranchName,"release/") s tBranchName = "release/"_tBranchName
			s tCreateBranchCommand = tCommand_" checkout -b "_tBranchName
			s tSC = ..RunCmd(tCreateBranchCommand,.pOutput) $$$ThrowOnError(tSC)
			s tCommand = tCommand_" push --set-upstream origin "_tBranchName
		} elseif tCommandName = "Pull from Develop" {
			s tCommand = tCommand_" merge develop"
		} elseif tCommandName = "Pull from Team" {
			s tCommand = tCommand_" merge "_..TeamBranch()
		} elseif tCommandName = "Diff with Team" {
			
			s tCurrentBranch = ..CurrentBranch()
			
			//switch to team branch and pull it, in prep for diff with feature branch
			s tSwitchCommand = tCommand_" checkout "_..TeamBranch()
			s tSC = ..RunCmd(tSwitchCommand,.pOutput) $$$ThrowOnError(tSC)
			
			s tPullCommand = tCommand_" pull --rebase"
			s tSC = ..RunCmd(tPullCommand,.pOutput) $$$ThrowOnError(tSC)
			
			//Now switch back to do the Diff
			s tSwitchCommand = tCommand_" checkout "_tCurrentBranch
			s tSC = ..RunCmd(tSwitchCommand,.pOutput) $$$ThrowOnError(tSC)
			s pOutput($I(pOutput))="-------------------------------"
			s pOutput($I(pOutput))=""
			s pOutput($I(pOutput))="Changed files on feature branch compared to team branch:"
			s pOutput($I(pOutput))=""
			//Diff compares the current HEAD (last commit on current branch) to a target branch.  Used to evaluate completeness of release branch.
			s tCommand = tCommand_" diff --name-only HEAD "_..TeamBranch()

		} elseif tCommandName = "Merge to Team and Delete" {
			//First, get the current branch
			s tCurrentBranch = ..CurrentBranch()
			
			//Push the feature branch to remote
			s tPushCommand = tCommand_" push"
			s tSC = ..RunCmd(tPushCommand,.pOutput) $$$ThrowOnError(tSC)

			//Then check out the team branch to merge to
			s tCheckoutTargetBranch = tCommand_" checkout "_..TeamBranch()
			s tSC = ..RunCmd(tCheckoutTargetBranch,.pOutput) $$$ThrowOnError(tSC)
			
			//First Pull the team branch
			s tPullTeamCommand = tCommand_" pull --rebase"
			s tSC = ..RunCmd(tPullTeamCommand,.pOutput) $$$ThrowOnError(tSC)

			//Then do the merge
			s tMergeTeamCommand = tCommand_" merge --squash "_tCurrentBranch
			s tSC = ..RunCmd(tMergeTeamCommand,.pOutput) $$$ThrowOnError(tSC)
			
			s tMergeCommitCommand = tCommand_" commit -m ""merge commit from feature branch: "_tCurrentBranch_""""
			s tSC = ..RunCmd(tMergeCommitCommand,.pOutput) $$$ThrowOnError(tSC)
			
			//Push the merged team branch to remote
			s tTeamPushCommand = tCommand_" push"
			s tSC = ..RunCmd(tTeamPushCommand,.pOutput) $$$ThrowOnError(tSC)

			//Now checkout the feature branch to delete it
			s tCheckoutCurrentBranch = tCommand_" checkout "_tCurrentBranch
			s tSC = ..RunCmd(tCheckoutCurrentBranch,.pOutput) $$$ThrowOnError(tSC)

 			//Now delete the feature branch from remote
			s tRemoteDeleteCommand = tCommand_" push --delete origin "_tCurrentBranch
			s tSC = ..RunCmd(tRemoteDeleteCommand,.pOutput) $$$ThrowOnError(tSC)

			//Now checkout the team branch in order to delete the local feature branch
			s tSC = ..RunCmd(tCheckoutTargetBranch,.pOutput) $$$ThrowOnError(tSC)

			//Now delete the feature branch using -D to force the delete
			s tCommand = tCommand_" branch -D "_tCurrentBranch
			
		}
		
		s tSC = ..RunCmd(tCommand,.pOutput) $$$ThrowOnError(tSC)
				
	} catch e {
		//s tSC = e.AsStatus()
		s pOutput(1)="Command could not be completed due to error: "_e.DisplayString()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="GitCommand">
<ClassMethod>1</ClassMethod>
<FormalSpec>commandName:%String,itemName:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	
	#dim tSC As %Status = $$$OK
	#dim e As %Exception.AbstractException
	
	Try {
		
		s tDisplay = 1
		s tCommand = ..GitCmdPrefix()
	
		if commandName="add" {
			s tCommand = tCommand_" add "_itemName
		} elseif commandName="remove" {
			s tCommand = tCommand_" rm -f "_itemName
		} elseif commandName="pull" {
			//Pull before every export to always get latest updates from other developers in order to avoid conflicts when pushing.
			s tCommand = tCommand_" pull"
		} elseif commandName="checkout" {
			//Pull before every export to always get latest updates from other developers in order to avoid conflicts when pushing.
			s tCommand = tCommand_" checkout "_itemName
		}

		s tSC = ..RunCmd(tCommand,.tOutput,tDisplay) $$$ThrowOnError(tSC)
		
		For i=1:1:tOutput {
			w !,tOutput(i)
		}
		w !
		
	} catch e {
		s tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="RunCmd">
<Description><![CDATA[
Run a shell command and report any error message, return <var>output</var> with 
lines as subscripts of the array if <var>stream</var> is false (the default) but if
<var>stream</var> is true then we will return the output as a stream to be read by the caller.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[cmd:%String,&output:%String,display:%Boolean=1,stream:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc=$$$OK,text=cmd
	set output=$G(output)+0 //This is to initialize the variable if it doesn't exist, but not increment it if it does exist
	If display Write !,"CMD: ",text
	
	Set outputfile=##class(%File).TempFilename("out")
	Set rc=$zf(-1,cmd_" 2> """_outputfile_""""_" 1>&2")
	Set outputstream=##class(%FileCharacterStream).%New()
	Set outputstream.Filename=outputfile

	If stream {
		Set output=outputstream,outputstream.RemoveOnClose=1
	} Else {
		If outputstream.Size>0 {
			Do outputstream.Rewind()
			While 'outputstream.AtEnd {
				Set line=outputstream.ReadLine()
				Set output($increment(output))=line
			}
		}
		Do outputstream.Clear()
	}
	Quit sc
]]></Implementation>
</Method>

<Method name="IsMenuGitCommand">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>menuItemName:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[$F(..#GitMenuItems, ","_menuItemName_",") > 0
]]></Implementation>
</Method>

<Method name="IsFeatureMenuGitCommand">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>menuItemName:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[$F(..#GitFeatureMenuItems, ","_menuItemName_",") > 0
]]></Implementation>
</Method>

<Method name="IsContextMenuGitCommand">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>menuItemName:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[$F(..#GitContextMenuItems, ","_menuItemName_",") > 0
]]></Implementation>
</Method>

<Method name="UserAction">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[InternalName:%String,MenuName:%String,&Target:%String,&Action:%String,&Reload:%Boolean]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #dim folder As %String = ..RepoFolder()
    #dim menuName As %String = $piece(MenuName,",")
    #dim menuItemName As %String = $piece(MenuName,",",2)
    #dim ec As %Status = $$$OK
    
    if (menuName = "Source Control Main Menu") {
        if (menuItemName = "Settings") {
            s Action = 2
            #dim defNamespace As %String = ..#InstallNamespace
            Set Target="/csp/healthshare/"_$ZCVT($NAMESPACE,"L")_"/User.SourceControl.Git.Setting.cls"
        } elseif ..IsMenuGitCommand(menuItemName) || ..IsFeatureMenuGitCommand(menuItemName) {
            s Action = 2
            s Target = "/csp/healthshare/"_$ZCVT($NAMESPACE,"L")_"/User.SourceControl.Git.Dialogue.cls?UserAction="_menuItemName
        } elseif (menuItemName = "Resolve Merge Conflicts") {
            s Action = 2
            s Target = "/csp/healthshare/"_$ZCVT($NAMESPACE,"L")_"/User.SourceControl.Git.MergeConflicts.cls"        
        }
    }elseif (menuName [ "Context") {
        if (menuItemName = "Add To") {
            s ec = ..AddToSourceControl(InternalName)
        } elseif (menuItemName = "Remove From") {
            s ec = ..RemoveFromSourceControl(InternalName)
        } elseif (menuItemName = "Check Out") {
            s ec = ..CheckOut(InternalName)
        } elseif (menuItemName = "Check In") {
            s ec = ..CheckIn(InternalName)
        } elseif ..IsContextMenuGitCommand(menuItemName) {
            s Action = 3
            //Currently there are no context menu git commands other than Add and Remove which are handled separately
            //s Target = ..GitCommand(command, InternalName)
        }
        
    }
#;    if (..#IsSYNC = 1) && (Action = 3) {
#;        s Action = 0
#;        d $zf(-1, "set HOME="_..RepoFolder()_"&"_Target)
#;    }

    Quit ec
]]></Implementation>
</Method>

<Method name="AfterUserAction">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[Type:%Integer,Name:%String,InternalName:%String,Answer:%Integer,Msg:%String="",&Reload:%Boolean]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[    Quit $$$OK
]]></Implementation>
</Method>

<Method name="IsNamespaceInGit">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[##class(%File).Exists(..RepoFolder()_".git")
]]></Implementation>
</Method>

<Method name="InternalName">
<Description>
Only returns internal name if files was exported via source control which sets the ExternNames subscript</Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$G(@..InstallNamespaceStorage()@("ExternalNames",name))
]]></Implementation>
</Method>

<Method name="ExternalName">
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    s InternalName = name
    
    If $System.Version.GetOS()="Windows" {
	    s tBackslash = "\"
	    s name = $TR(name,"/", tBackslash)
    } else {
	    s tBackslash = "/"
    }
    
    // lower case for extensions
    #dim extension As %String = $ZCVT($P(name,".",$L(name,".")),"L")
    s $P(name,".",$L(name,".")) = extension
    
    // we shall put classes in different folders
    if extension = "cls" {
        s name = $TR( $P(name,".", 1, $L(name,".")-1), ".", tBackslash)_".cls"
    }
    
    // we shall delete csp-app from csp files
    if $E(name, 1) = tBackslash {
        s $E(name, 1) = ""
    }
    if $P(name, tBackslash, 1) = "csp" {
        s $P(name, tBackslash, 1, 2) = "csp"
    }

	// put all items into a subfolder 
	s name = tBackslash_name

    s name = $TR(name," *?","___")_".xml"
    
    s @..InstallNamespaceStorage()@("ExternalNames",name) = InternalName
    
    Quit name
]]></Implementation>
</Method>

<Method name="AddToSourceControl">
<ClassMethod>1</ClassMethod>
<FormalSpec>InternalName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #dim i, item, sc
    #dim tSC As %Status = $$$OK
    For i = 1:1:$L(InternalName, ",") {
        Set item = $P(InternalName, ",", i)
        Set @..InstallNamespaceStorage()@("items", item) = ""
        Set sc =  ..ExportItem(item)
        Set tSC = $$$ADDSC(sc, tSC)
        Set sc =  ..CheckOutItem(item)
        Set tSC = $$$ADDSC(sc, tSC)

    }
    Quit tSC
]]></Implementation>
</Method>

<Method name="IsCheckedOut">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[InternalName:%String,&pUserName:%String=""]]></FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	#dim isCheckedOut As %Boolean = 0
	
	Set isCheckedOut = $D(@..InstallNamespaceStorage()@("locks",InternalName)) > 0
	
	if isCheckedOut Set pUserName = @..InstallNamespaceStorage()@("locks",InternalName)
	
	Quit isCheckedOut
]]></Implementation>
</Method>

<Method name="CheckOut">
<ClassMethod>1</ClassMethod>
<FormalSpec>InternalName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #dim i, item, sc
    #dim tSC As %Status = $$$OK
    For i = 1:1:$L(InternalName, ",") {
        Set item = $P(InternalName, ",", i)
        Set sc =  ..CheckOutItem(item)
        Set tSC = $$$ADDSC(sc, tSC)

    }
    Quit tSC
]]></Implementation>
</Method>

<Method name="CheckOutItem">
<ClassMethod>1</ClassMethod>
<FormalSpec>InternalName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set @..InstallNamespaceStorage()@("locks", InternalName) = $USERNAME
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="CheckIn">
<ClassMethod>1</ClassMethod>
<FormalSpec>InternalName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #dim i, item, sc
    #dim tSC As %Status = $$$OK
    For i = 1:1:$L(InternalName, ",") {
        Set item = $P(InternalName, ",", i)
        Set sc =  ..CheckInItem(item)
        Set tSC = $$$ADDSC(sc, tSC)

    }
    Quit tSC
]]></Implementation>
</Method>

<Method name="CheckInItem">
<ClassMethod>1</ClassMethod>
<FormalSpec>InternalName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Kill @..InstallNamespaceStorage()@("locks", InternalName)
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="IsStaged">
<ClassMethod>1</ClassMethod>
<FormalSpec>InternalName:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	#dim tSC As %Status = $$$OK
	#dim tReturn As %Boolean = 0
	s tExternalName = ..ExternalName(InternalName)
	if "/\" [ $E(tExternalName,1,1) s tExternalName = $E(tExternalName,2,*)
	s tCommand = ..GitCmdPrefix()
	s tCommand = tCommand_" status --short"
	s tDisplay = 0
	s tSC = ..RunCmd(tCommand,.tOutput,tDisplay)
	if $$$ISERR(tSC) Quit
	For i=1:1:tOutput {
		s tOutputLine = tOutput(i)
		s tStagedItem = $E(tOutputLine,4,*)
		if tStagedItem = tExternalName {
			s tReturn = 1
		}		
	}
	Quit tReturn
]]></Implementation>
</Method>

<Method name="DeleteExternalsForItem">
<ClassMethod>1</ClassMethod>
<FormalSpec>InternalName:%String,FullExternalName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #dim type As %String = ..Type(InternalName)
    #dim ec As %Status = $$$OK
    if (type = "prj") || (type = "pkg") || (type = "csp" && ..IsCspFolder(InternalName)) {
        // we delete complex items

	//The .itemsList is not for the specific item selected whether csp folder, pkg, or prj - it seems to be hardcoded to the repo folder or a specific folder for ereferral
	//So, if delete of prj, pkg, or csp folder is need, revisit this code.        
#;        //get all item in files
#;        #dim itemsList
#;        $$$QuitOnError(..ListItemsInFiles(.itemsList))
#;        
#;        #dim item As %String = ""
#;        //for all item in files
#;        For  {
#;            s item = $O(itemsList(item))
#;            Quit:item=""
#;            
#;            //if item is not in sc -- delete file
#;            if '..IsInSourceControl(item) {
#;                #dim sc As %Status = ..DeleteExternalFile(item)
#;                if 'sc {
#;                    s ec = $$$ADDSC(ec, sc)
#;                }
#;            }
#;        }
    } else {
        s ec = ..DeleteExternalFile(InternalName,FullExternalName)
    }
    Quit ec
]]></Implementation>
</Method>

<Method name="RemoveFromSourceControl">
<ClassMethod>1</ClassMethod>
<FormalSpec>InternalName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #dim sc As %Status = $$$OK
    if $D(@..InstallNamespaceStorage()@("items", InternalName)) {
        //Get external file name first because items contains LibType reference
        s tFilename = ..ExternalName(InternalName)
        s tFullFilename = ..FullExternalName(InternalName)
        k @..InstallNamespaceStorage()@("items", InternalName)
        K @..InstallNamespaceStorage()@("ExternalNames",tFilename)
        s sc = ..DeleteExternalsForItem(InternalName,tFullFilename)
        Q:$$$ISERR(sc) sc
        s sc = ..GitCommand("remove",tFullFilename)
        Q:$$$ISERR(sc) sc
        d ..RemoveFolderIfEmpty(..RepoFolder())
    } else {
        #dim parentElement As %String = ""
        if ..IsInSourceControl(InternalName, .parentElement) {
            s sc = ..MakeError("This element is contained in "_parentElement_" that tracked by SourceControl")
        }else {
            s sc = ..MakeError("Element is not in SourceControl")
        }
        
    }
    Quit sc
]]></Implementation>
</Method>

<Method name="IsCspFolder">
<ClassMethod>1</ClassMethod>
<FormalSpec>InternalName:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    #dim extension = $P(InternalName, ".", $L(InternalName, "."))
    Quit:extension="csp" 0
    
    #dim filename = $system.CSP.GetFileName(InternalName_"/")
    Quit filename'="" && ##class(%File).DirectoryExists(filename)
]]></Implementation>
</Method>

<Method name="Type">
<Description><![CDATA[
pkg -- package<br/>
prj -- project<br/>
csp -- csp-page or csp-folder. See <Method>IsCspFolder</Method>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>InternalName:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    #dim extension As %String = $ZCVT($P(InternalName,".",$L(InternalName,".")),"L")
    #dim type As %String = extension
    
    if $E(InternalName, 1, 4) = "/csp" {
        s type ="csp"
    }

    Quit type
]]></Implementation>
</Method>

<Method name="NameWithoutExtension">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>InternalName:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$piece(InternalName, ".", 1, $length(InternalName,".")-1)
]]></Implementation>
</Method>

<Method name="IsClassInPackage">
<Description>
packageName without extension</Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>ClassName:%String,packageName:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[$E(ClassName, 1, $L(packageName)) = packageName
]]></Implementation>
</Method>

<Method name="IsItemInProject">
<Description>
projectName without extension</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>InternalName:%String,projectName:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    // we should check two cases
    // direct inclusion
    // inclusion in package or csp-folder that contained in project
    #dim type As %String = ..Type(InternalName)
    //w InternalName, "->"
    #dim name As %String = $case(type, "cls": ..NameWithoutExtension(InternalName), 
                                       "pkg": $TR(..NameWithoutExtension(InternalName), "/", "."), 
                                       "csp": $E(InternalName, 2, *),
                                       :InternalName)
    if $E(name) = "." && (type = "pkg") {
        s $E(name) = ""
    }
    
    //w name, " "
    #dim checkId = projectName_"||"_name_"||"_$ZCVT(type,"U")
    //w checkId
    #dim isItemInProject As %Boolean = ##class(%Studio.ProjectItem).%ExistsId(checkId)
    //w " ", isItemInProject, !
    
    #dim i As %Integer
    if 'isItemInProject && ((type = "cls") || (type="pkg")) {
        for i = 1:1:$L(name, ".") {
            s checkId = projectName_"||"_$P(name, ".", 1, i)_"||PKG"
            //w checkId, !
            if ##class(%Studio.ProjectItem).%ExistsId(checkId) {
                s isItemInProject = 1
                Quit
            }
        }
    }
    
    if 'isItemInProject && (type = "csp") {
        for i = 1:1:$L(name, "/") {
            s checkId = projectName_"||"_$P(name, "/", 1, i)_"||DIR"
            
            if ##class(%Studio.ProjectItem).%ExistsId(checkId) {
                s isItemInProject = 1
                Quit
            }
        }
    }
    Quit isItemInProject
]]></Implementation>
</Method>

<Method name="IsItemInCSPFolder">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>InternalName:%String,cspFolder:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[$E(InternalName, 1, $L(cspFolder)) = cspFolder
]]></Implementation>
</Method>

<Method name="FindInPackages">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[InternalName:%String,&sourceControlItem:%String]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    #dim item As %String = ""
    #dim found As %Boolean = 0
    For  {
        s item = $O(@..InstallNamespaceStorage()@("items", item))
        Quit:item=""
        continue:..Type(item)'="pkg"
        #dim packageName As %String = ..NameWithoutExtension(item)

        if ..IsClassInPackage(InternalName, packageName) {
            s found = 1
            s sourceControlItem = packageName
            Quit
        }
    }
    Quit found
]]></Implementation>
</Method>

<Method name="FindInProjects">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[InternalName:%String,&sourceControlItem:%String]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    #dim item As %String = ""
    #dim found As %Boolean = 0
    For  {
        s item = $O(@..InstallNamespaceStorage()@("items", item))
        Quit:item=""
        continue:..Type(item)'="prj"
        #dim projectName As %String = ..NameWithoutExtension(item)
        
        if ..IsItemInProject(InternalName, projectName) {
            s found = 1
            s sourceControlItem = projectName
            Quit
        }
    }
    Quit found
]]></Implementation>
</Method>

<Method name="FindInCspFolders">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[InternalName:%String,&sourceControlItem:%String]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    #dim cspFolder As %String = ""
    #dim found As %Boolean = 0
    For  {
        s cspFolder = $O(@..InstallNamespaceStorage()@("items", cspFolder))
        Quit:cspFolder=""
        continue:'(..Type(cspFolder)="csp" && ..IsCspFolder(cspFolder))
        
        if ..IsItemInCSPFolder(InternalName, cspFolder) {
            s found = 1
            s sourceControlItem = cspFolder
            Quit 
        }
    }
    Quit found
]]></Implementation>
</Method>

<Method name="IsInSourceControl">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[InternalName:%String,&sourceControlItem:%String]]></FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    #dim isInSourceControl As %Boolean = 1
    
    s isInSourceControl = $D(@..InstallNamespaceStorage()@("items",InternalName)) > 0
    if isInSourceControl {
        s sourceControlItem = InternalName
    }else {
        //if no direct reference maybe we have to look in packages, projects or csp-apps ?
        //We have three groups of routines
        //packages for classes
        //projects for everything
        //csp-folders for csp and static files

        #dim type As %String = ..Type(InternalName)
        if type = "cls" {
            s isInSourceControl = ..FindInPackages(InternalName, .sourceControlItem)
        } elseif type = "csp" {
            s isInSourceControl = ..FindInCspFolders(InternalName, .sourceControlItem)
        }
        
        // our last chance to find item -- let's look in projects
        if 'isInSourceControl {
            s isInSourceControl = ..FindInProjects(InternalName, .sourceControlItem)
        }
    }
    //w "checking ", $G(type), " ", InternalName, "=", isInSourceControl, !
    Quit isInSourceControl
]]></Implementation>
</Method>

<Method name="FullExternalName">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>InternalName:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$E(..RepoFolder(),1,*-1)_..ExternalName(InternalName)
]]></Implementation>
</Method>

<Method name="NormalizeExtension">
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    #dim extension = $P(name, ".", $L(name, "."))
    if $L(extension) <= 3 {
        s $P(name, ".", $L(name, ".")) = $zcvt(extension, "L")
    }
    Quit name
]]></Implementation>
</Method>

<Method name="RoutineTSH">
<ClassMethod>1</ClassMethod>
<FormalSpec>InternalName:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    #dim type = ..Type(InternalName)
    //for csp-files (csp,js,html,css, all that stored in csp/...) we always check for changes in external file
    #dim tsh = $case(type,"csp":"",:$G(@..InstallNamespaceStorage()@("TSH", ..NormalizeExtension(InternalName))))
    if tsh = "" {
        #dim ts As %String = ##class(%RoutineMgr).TS(InternalName)
        if ts '= "" {
            // prj files have milliseconds in timestamp, so we crop them
            s tsh = $P($zdth(ts, 3),".",1)
        }
    }
    Quit tsh
]]></Implementation>
</Method>

<Method name="UpdateRoutineTSH">
<ClassMethod>1</ClassMethod>
<FormalSpec>InternalName:%String,tsh:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    s @..InstallNamespaceStorage()@("TSH", ..NormalizeExtension(InternalName)) = $G(tsh, $H)
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="RemoveRoutineTSH">
<ClassMethod>1</ClassMethod>
<FormalSpec>InternalName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    k @..InstallNamespaceStorage()@("TSH", ..NormalizeExtension(InternalName))
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="DeleteExternalFile">
<ClassMethod>1</ClassMethod>
<FormalSpec>InternalName:%String="",FullExternalName:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    if FullExternalName'="" {
    	set fullName = FullExternalName
    } else {
	    set fullName = ..FullExternalName(InternalName)
    }
    #dim tSC As %Status = $$$OK
    if ##class(%File).Exists(fullName) {
        s tSC = ##class(%File).Delete(fullName)
        if 'tSC {
	        s tSC = $$$ERROR($$$GeneralError,"Unable to delete file: "_fullName)
        } else {
	        d ..RemoveRoutineTSH(InternalName)
	        s tSC = ..GitCommand("remove",fullName)
	        w fullName, " for ", InternalName, " deleted!",!
        }
    }
    Quit tSC
]]></Implementation>
</Method>

<Method name="ListItemsInFiles">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&itemList,&err]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	//This method doesn't seem to do what it should do
	//It seems to get a list of items in a folder on disk using the ImportDir method
	//Shouldn't it get a list of items in the relevant prj, pkg, or csp folder?
	
#;    #define DoNotLoad 1
#;	// PR: Must find a better solution for tSubDir. *.cls.xml wildcard not working. Want to use the same git repository for client-side and server-side.
#;    set tSubDir = $CASE($FIND($ZCONVERT(..RepoFolder(),"U"),"EREFERRAL") > 0, 1:"eReferral",:"")
#;    $$$QuitOnError($system.OBJ.ImportDir(..RepoFolder()_tSubDir,"*.xml","-d",.err,1, .itemList, $$$DoNotLoad))
#;    
#;    //change all csp/ names to /csp/ names
#;    #dim item As %String = "csp"
#;    For  {
#;        s item = $O(itemList(item))
#;        Quit:item=""
#;        Quit:$E(item, 1, 4)'="csp/"
#;        k itemList(item)
#;        s itemList("/"_item)=""
#;    }
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="ExportRoutinesAux">
<ClassMethod>1</ClassMethod>
<FormalSpec>path:%String,sep:%String="",level:%Integer=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #define Dir
    #define OrderBy
    #define SystemFiles
    #define Flat
    #define NotStudio
    #define ShowGenerated 0
    #define Filter
    #define CspFile 5
    #define Directory 9
    #define CSPFolder 10
    
    #dim rs As %ResultSet = ##class(%ResultSet).%New("%RoutineMgr:StudioOpenDialog")
    #dim ec As %Status = rs.Execute(path_$case(path,"":"",:"/")_"*",$$$Dir, $$$OrderBy, $$$SystemFiles, $$$Flat, $$$NotStudio, $$$ShowGenerated, $$$Filter)
    Quit:'ec ec
    while rs.Next() {
        #dim name As %String = rs.Get("Name")
        #dim isdirectory As %String = rs.Get("IsDirectory")
        #dim type As %String = rs.Get("Type")
        
        if (type = $$$Directory) || (type = $$$CSPFolder) {
            #dim newpath As %String = $case(path,"":name,:path_isdirectory_name)
            #dim importedcnt As %Integer = 0
            d ..ExportRoutinesAux(newpath, isdirectory, level + 1)
        } else {
            #dim InternalName As %String = path_sep_name
            if (type = $$$CspFile) && ($E(InternalName) '= "/") {
                s InternalName = "/"_InternalName
            }
            s ec = ..ExportItem(InternalName)
        }
    }
    k rs
    Quit ec
]]></Implementation>
</Method>

<Method name="ExportItem">
<ClassMethod>1</ClassMethod>
<FormalSpec>InternalName:%String,expand:%Boolean=1</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #dim type = ..Type(InternalName)
    if type = "pkg" {
        $$$QuitOnError(..ExportRoutinesAux(..NameWithoutExtension(InternalName), "."))
    }elseif type = "prj" && expand {
	    //No handling for .prj files required
#;        $$$QuitOnError(..ExportProject(..NameWithoutExtension(InternalName)))
#;        $$$QuitOnError(..ExportItem(InternalName, 0))
    }elseif type = "ptd" {
	    //No handling for .ptd files required
    }elseif (type = "csp") && ..IsCspFolder(InternalName) {
        $$$QuitOnError(..ExportRoutinesAux(InternalName , "/"))
    }else {
        w "Exporting ", InternalName, !
        #dim filename As %String = ..FullExternalName(InternalName)
        #;Do not include selectivity as it
        #; 1. is likely to come from a dev system which does not have representative data
        #; 2. may have elements that cannot be imported into earlier versions of Cache
        
   //Disable this for now...
        //We know the database version of the file is always the latest
        //However, our local git repo may not have the latest that is in the remote repo
        //Therefore, when export to our local repo, we may create a conflict because we don't have the latest from the remote repo
        //So, because we know that the database version is the latest, we can discard what is in our local repo,
        //get the latest that is in the remote repo, which may contain edits not in our local repo
        //And then we will export a new copy of the database version which will contain our new edits 
        //but will be an addition, not a conflict to what was in the remote repo.
        //s tSC = ..GitCommand("checkout",filename)
        //s tSC = ..GitCommand("pull")
        //$$$QuitOnError(tSC)
   //
        
        if ..#UseUDL,..CanExportExtensionUDL(type) {
			$$$QuitOnError($system.OBJ.ExportUDL(InternalName, filename, "-d/diffexport=1/exportselectivity=0"))
		} else {
			$$$QuitOnError($system.OBJ.Export(InternalName, filename,"-d/diffexport=1/exportselectivity=0"))	
		}
		
        $$$QuitOnError(..UpdateRoutineTSH(InternalName, $H))
        s tSC = ..GitCommand("add",filename)
        $$$QuitOnError(tSC)
		
    }
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="ExportProject">
<ClassMethod>1</ClassMethod>
<FormalSpec>project:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #dim rs As %ResultSet = ##class(%ResultSet).%New("%Studio.Project:ProjectItemsList")
    $$$QuitOnError(rs.Execute(project))
    #dim typesWithoutExtension As %List = $LB("CLS", "PKG")
    while rs.Next() {
        #dim name = rs.Get("Name")
        if $LF(typesWithoutExtension, rs.Get("Type")) {
            s name = name _ "." _ rs.Get("Type")
        }
        #dim ec As %Status = ..ExportItem(name)
        Quit:'ec
    }
    k rs
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="ExportAll">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #dim item As %String = ""
    #dim ec As %Status = $$$OK
    For  {
        s item = $O(@..InstallNamespaceStorage()@("items",item))
        Quit:item=""
        s ec = ..ExportItem(item)
        Quit:'ec       
    }
    Quit ec
]]></Implementation>
</Method>

<Method name="RemoveFolderIfEmpty">
<Description>
returns true if directory was deleted</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>path:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    #dim rs As %Status = ##class(%ResultSet).%New("%File:FileSet")
    #define DirsFirst 1
    $$$QuitOnError(rs.Execute(path,,,$$$DirsFirst))
    #dim fileCount As %Integer = 0
    while rs.Next() {
        #dim fullname As %String = rs.Get("Name")
        #dim type As %String = rs.Get("Type")
        #dim name As %String = rs.Get("ItemName")
        #define IsDirectory(%type) %type="D"
        
        s fileCount = fileCount + 1
        Quit:'$$$IsDirectory(type)
        continue:name=".git"
        if ..RemoveFolderIfEmpty(fullname) {
            s fileCount = fileCount - 1
        }
    }
    if fileCount = 0 {
        d ##class(%File).RemoveDirectory(path)
    }
    k rs
    Quit 'fileCount
]]></Implementation>
</Method>

<Method name="CanExportExtensionUDL">
<Description>

Returns if an extension can </Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>extension:%String=""</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[	quit ($listfind(..#NOTUDLEXTENSIONS, extension)=0)
]]></Implementation>
</Method>

<Method name="TestDialogue">
<ClassMethod>1</ClassMethod>
<FormalSpec>pMenuCommand,pCommandValue=""</FormalSpec>
<Implementation><![CDATA[
	s tSettings(pMenuCommand)=pCommandValue
	s tSC = ..HandleDialogue(.tSettings,.tOutput)
	For i=1:1:tOutput {
		w !,tOutput(i)
	}
]]></Implementation>
</Method>

<Method name="LoadSettings">
<ClassMethod>1</ClassMethod>
<FormalSpec>pRepoBaseFolder,pUserName,pRepoURL,pRepoProtocol,pPersonName,pPersonEmail</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	
	Set tSettings("repoBaseFolder")=pRepoBaseFolder
	Set tSettings("userName")=pUserName
	Set tSettings("repoURL")=pRepoURL
	Set tSettings("repoProtocol")=pRepoProtocol
	Set tSettings("personName")=pPersonName
	Set tSettings("personEmail")=pPersonEmail
	d ##class(User.SourceControl.Git.Utils).UpdateSettings(.tSettings)
]]></Implementation>
</Method>

<Method name="LoadBranch">
<ClassMethod>1</ClassMethod>
<FormalSpec>pBranch,pPassword</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	
	#dim tSC As %Status = $$$OK
	#dim e As %Exception.AbstractException
	
	Try {
		
		s tOutput=""
		
		if '..IsNamespaceInGit() {
			s tSettings("Clone Repository")=pPassword
			s tSC=..HandleDialogue(.tSettings,.tOutput)
			$$$ThrowOnError(tSC)
		}
		
		Kill tSettings
		s tSettings("Switch to Branch")=pBranch
		s tSC=..HandleDialogue(.tSettings,.tOutput)
		$$$ThrowOnError(tSC)
		
		Kill tSettings
		s tSettings("Pull")=pBranch
		s tSC=..HandleDialogue(.tSettings,.tOutput)
		$$$ThrowOnError(tSC)
		
		//LoadDir is .xml only - do we need to switch to ImportDir to handle csp files?
		s (tErrors,tLoaded)=""
		s tSC = $System.OBJ.ImportDir(..RepoFolder(),"*.xml","cbfk",.tErrors,1,.tLoaded)
		
	} catch e {
		//s tSC = e.AsStatus()
		//w !,e.DisplayString()
	}
	
	for i=1:1:tOutput {
		w tOutput(i)
	}
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="BuildDeployment">
<ClassMethod>1</ClassMethod>
<FormalSpec>pFilename,pIntegrationBranch,pSourceBranch</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tSC As %Status = $$$OK
	#dim e As %Exception.AbstractException
	#dim tStream As %Stream.Object
	
	Try {

		Kill tSettings
		s tSettings("Switch to Branch")=pSourceBranch
		Kill tOutput
		s tSC=..HandleDialogue(.tSettings,.tOutput)
		$$$ThrowOnError(tSC)
		
		Kill tSettings
		s tSettings("Pull")=pSourceBranch
		Kill tOutput
		s tSC=..HandleDialogue(.tSettings,.tOutput)
		$$$ThrowOnError(tSC)

		//Switch to the integration branch in order to do the diff with the source branch
		Kill tSettings		
		s tSettings("Switch to Branch")=pIntegrationBranch
		Kill tOutput
		s tSC=..HandleDialogue(.tSettings,.tOutput)
		$$$ThrowOnError(tSC)
		
		//Get the new/changed files in the diff between integration branch and source branch
		Kill tSettings
		s tSettings("ListDiff")=pSourceBranch
		Kill tOutput
		s tSC=..HandleDialogue(.tSettings,.tOutput)
		$$$ThrowOnError(tSC)
		
		Merge tImportList = tOutput
		
		//Now that we have the list, switch to the source branch and load the files, ensuring each compile
		Kill tSettings
		s tSettings("Switch to Branch")=pSourceBranch
		Kill tOutput
		s tSC=..HandleDialogue(.tSettings,.tOutput)
		$$$ThrowOnError(tSC)
		
		s tLoadList = ""
		for i=1:1:tImportList {
			s tItem=tImportList(i)
			s tLoadList = tLoadList_$S(tLoadList="":"",1:"*")_..RepoFolder()_tItem
			s tExtension = $P(tItem,".",$LENGTH(tItem,"."))
			s tInternalName = tItem
			if tExtension = "xml" {
				s tInternalName = $REPLACE(tInternalName,".xml","")
			}
			s tItemExtension = $P(tInternalName,".",$LENGTH(tInternalName,"."))
			s tInternalName = $REPLACE(tInternalName,"."_tItemExtension,"."_$ZCVT(tItemExtension,"U"))
			s tInternalName = $TR(tInternalName,"/",".")
			if tInternalName="" Continue
			
			Set tContentsList(tInternalName)=""

		}
		
		//a load list is compiled here so that multiple files can be loaded at one so that class DependsOn statements can be honored
		//But concern is whether the tLoadList may become too large?
		s tSC = $System.OBJ.Load(tLoadList,"cbfk") $$$ThrowOnError(tSC)
		
		s tProjectName = $TR(pIntegrationBranch,"/","")
		s tProductionName = ""
		//Set:(tItemName '[ "||") tItemName = tProductionName_"||"_tItemName
		
		Set tProductionClassIncluded = 0
		Set tComments = "Deploy Package created programatically."
		Set tSC =##class(Ens.Deployment.Utils).CreateExportPackageFromProjectList(tProjectName,.tContentsList,pFilename,tProductionName,tComments,tProductionClassIncluded)
		$$$ThrowOnError(tSC)

		w !, "Deploy Package built and exported to: "_pFilename
		
	} catch e {
		s tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="LoadDeployment">
<ClassMethod>1</ClassMethod>
<FormalSpec>pFilename</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tSC As %Status = $$$OK
	#dim e As %Exception.AbstractException
	
	Try {
		
		//C:\InterSystems\HealthShare\mgr\Temp\intdevelop20191202132903.xml
		
		Set outputfile=##class(%File).TempFilename("compile")
		OPEN outputfile:"WSN"
		USE outputfile

		
		
		if ##class(%File).Exists(pFilename) {
			s tProduction = "" //$G(^Ens.Configuration("csp","LastProduction"))
			Do ##class(Ens.Deployment.Utils).GenerateFileNames(pFilename,.tRollbackFile,.tLogFile,.tReportFile)
			Set tCreateRollBack = 1, tAllowDeployToSource = 1 ,tAutoRevert = 1, tWhereToLog = "LC"
			s tSC = ##class(Ens.Deployment.Deploy).DeployCode(pFilename,tProduction,tCreateRollBack,tRollbackFile,tWhereToLog,tLogFile,tAllowDeployToSource,tAutoRevert)
			$$$ThrowOnError(tSC)
		} else {
			$$$ThrowOnError($$$ERROR($$$GeneralError,"File name for deployment not found: "_pFilename))
		}

		
		
	} catch e {
		s tSC = e.AsStatus()
		w e.DisplayString()
	}
	
	CLOSE outputfile
	
	s tFile=##class(%FileCharacterStream).%New()
	s tFile.Filename=outputfile
	While 'tFile.AtEnd {
		w tFile.ReadLine()
	}	
	d tFile.Clear()
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="DeployRollback">
<ClassMethod>1</ClassMethod>
<FormalSpec>pFilename:%String,pTargetHost:%String,pTargetPort:%String,pTargetNamespace:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	
	#dim tSC As %Status = $$$OK
	#dim e As %Exception.AbstractException
	#dim tDeployStatus As %Boolean = 1
	
	Try {
		
		s tResponse="-------------------------------"_$C(10)
		s tResponse=tResponse_"Rollback of last deployment to "_pTargetHost_":"_pTargetPort_$C(10)
		s tResponse=tResponse_"-------------------------------"_$C(10)		
		
		s tImportRequest = ##class(User.SourceControl.Deploy.ImportRequest).%New()
		s tImportRequest.CallBackMethod = "" //how do we determine the config script?
		
		Set tServiceClient=##class(User.SourceControl.Deploy.ServiceClient).%New()
		Set tServiceClient.Location="http://"_pTargetHost_":"_pTargetPort_"/csp/healthshare/"_$ZCVT(pTargetNamespace,"L")_"/services/User.SourceControl.Deploy.Service.cls"
		//Set tServiceClient.SSLConfiguration = tConfig.SSLConfig
		Set tServiceClient.Timeout = 300
		Set tCredentials = ##class(Ens.Config.Credentials).%OpenId("HS_Credentials")  //Build installer sets this on initial setup
		Set tSC=tServiceClient.WSSecurityLogin(tCredentials.Username,tCredentials.Password) $$$ThrowOnError(tSC)

		Set tResponse = tServiceClient.Rollback(tImportRequest,.tDeployStatus)

	} catch e {
		if $ZERROR["<ZSOAP>" {
            Set tSC=%objlasterror
        } else {
            Set tSC = e.AsStatus()
        }
		s tResponse="-------------------------------"_$C(10)
		s tResponse=tResponse_"Error deploying to "_pTargetHost_":"_pTargetPort_" = "_$System.Status.GetErrorText(tSC)_$C(10)
		s tResponse=tResponse_"-------------------------------"_$C(10)
		
		s tDeployStatus = 0
	}

	for i=1:1:$L(tResponse,$C(10)) {
		w !,$P(tResponse,$C(10),i)
	}

	Quit $C(10)_$CASE(tDeployStatus,1:"SUCCESS",0:"FAILURE",:"")
]]></Implementation>
</Method>

<Method name="Deploy">
<ClassMethod>1</ClassMethod>
<FormalSpec>pFilename:%String,pTargetHost:%String,pTargetPort:%String,pTargetNamespace:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tSC As %Status = $$$OK
	#dim e As %Exception.AbstractException
	#dim tDeployStatus As %Boolean = 1
	
	Try{
		
		//Not entirely sure how to handle this - perhaps we will call Deploy multiple times - once per system...
		//but if we do that we have to recreate the import request everytime
		//if we passed in the list of system, we could create it once and post it multiple times.
		//catching errors and doing the rollback may be easier in COS as well
		//The simplest solution right now is to call this method for each target and recreate the import request each time
		//so we'll start with that
		
		s tResponse="-------------------------------"_$C(10)
		s tResponse=tResponse_"Beginning deployment to "_pTargetHost_":"_pTargetPort_$C(10)
		s tResponse=tResponse_"-------------------------------"_$C(10)		
		
		//Create the Import Request and add one ImportObject to it.  The import object will be the deploy file.
		s tDeployStream = ##class(%FileCharacterStream).%New()
		s tDeployStream.Filename = pFilename
		
		s tImportRequest = ##class(User.SourceControl.Deploy.ImportRequest).%New()
		s tImportRequest.CallBackMethod = "" //how do we determine the config script?
		
		s tImportObject = ##class(User.SourceControl.Deploy.ImportObject).%New()
		s tSC = tImportObject.ObjectStream.CopyFrom(tDeployStream) $$$ThrowOnError(tSC)
		s tImportObject.Name = ##class(%File).GetFilename(pFilename)
		s tSC = tImportRequest.Objects.Insert(tImportObject) $$$ThrowOnError(tSC)
		
		Set tServiceClient=##class(User.SourceControl.Deploy.ServiceClient).%New()
		Set tServiceClient.Location="http://"_pTargetHost_":"_pTargetPort_"/csp/healthshare/"_$ZCVT(pTargetNamespace,"L")_"/services/User.SourceControl.Deploy.Service.cls"
		//Set tServiceClient.SSLConfiguration = tConfig.SSLConfig
		Set tServiceClient.Timeout = 300
		Set tCredentials = ##class(Ens.Config.Credentials).%OpenId("HS_Credentials")  //Build installer sets this on initial setup
		Set tSC=tServiceClient.WSSecurityLogin(tCredentials.Username,tCredentials.Password) $$$ThrowOnError(tSC)

		Set tResponse = tServiceClient.ImportClass(tImportRequest,.tDeployStatus)
		
	} catch e {
		if $ZERROR["<ZSOAP>" {
            Set tSC=%objlasterror
        } else {
            Set tSC = e.AsStatus()
        }
		s tResponse="-------------------------------"_$C(10)
		s tResponse=tResponse_"Error deploying to "_pTargetHost_":"_pTargetPort_" = "_$System.Status.GetErrorText(tSC)_$C(10)
		s tResponse=tResponse_"-------------------------------"_$C(10)
		
		s tDeployStatus = 0
	}

	for i=1:1:$L(tResponse,$C(10)) {
		w !,$P(tResponse,$C(10),i)
	}
	
	
	//test reutrn value
	w !,$I(^MS("count"))
	if ^MS("count")#2 = 0 s tDeployStatus = 0
	

	Quit $C(10)_$CASE(tDeployStatus,1:"SUCCESS",0:"FAILURE",:"")
]]></Implementation>
</Method>
</Class>


</Export>
